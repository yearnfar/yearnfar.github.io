<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 知识时光机</title><link>https://blog.yearnfar.com/posts/</link><description>Recent content in Posts on 知识时光机</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>yearnfar 2022</copyright><lastBuildDate>Mon, 16 May 2022 21:38:00 +0800</lastBuildDate><atom:link href="https://blog.yearnfar.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>为什么中国古人不能发明蒸汽机</title><link>https://blog.yearnfar.com/posts/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%AD%E5%9B%BD%E5%8F%A4%E4%BA%BA%E4%B8%8D%E8%83%BD%E5%8F%91%E6%98%8E%E8%92%B8%E6%B1%BD%E6%9C%BA/</link><pubDate>Mon, 16 May 2022 21:38:00 +0800</pubDate><guid>https://blog.yearnfar.com/posts/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%AD%E5%9B%BD%E5%8F%A4%E4%BA%BA%E4%B8%8D%E8%83%BD%E5%8F%91%E6%98%8E%E8%92%B8%E6%B1%BD%E6%9C%BA/</guid><description>以现代视角来看，蒸汽机原理并不算复杂，为什么古人在几千年的历史中都没有发明蒸汽机？我从来没有怀疑过古人的聪明智慧，但是没有发明蒸汽机，我相信有其中的必然原因。于是我带着一台瓦特改良的蒸汽机开始了我的穿越之旅。
蒸汽机VS汉朝黄牛 首先我穿越来到了汉朝，虽然在汉朝人们已经开始使用煤炭，但是并没有大规模应用，我只能使用木材当做燃料。
我请了一个樵夫，帮我打柴，并把蒸汽机搬到了广场上，向人们展示我的蒸汽机。
“它能做什么”？有人问道。
“他能推动磨盘，所有需要人力的事他都能做！”
“哦，跟水车一样啊。我看你往里面加木柴，但是水车不需要木柴呢！”
“水车只能建在有水的地方，我这个可以建在所有有水的地方。” 我气愤的说道。
“没有水的地方可以使用牛啊”又有人说道。
我竟然无言以对，想想也是，牛只需要吃草，既然耕地，拉磨，也能拉车。
于是在汉朝黄牛VS 蒸汽机，蒸汽机败了。
蒸汽机VS大明船帆 在认真分析了汉朝的失败经验后，我决定穿越到明朝。原因有二：
明朝已经开始大规模使用煤炭了，燃料问题解决了。 明朝航海业发达，大船&amp;amp;蒸汽机是个不错的落地方案。 于是我直接穿越到了明朝，找到郑和，向他推销我的蒸汽机。
“大人，这个设备可以装到大船上，代替人力，只需要烧煤炭就可以了。”我说道
“这个东西这么大，船甲板能承受得了这个重量吗？”郑和问道。
“甲板上都用铁板就可以了”。我自信满满的说道
“装满煤炭能去下西洋吗？到了没有煤的地方怎么办呢？”。郑和问道
“我&amp;hellip;&amp;quot;
到了明朝，我的蒸汽机面临了现在新能源一样的困境。里程焦虑，并不是每个地方都用煤炭可以买到煤炭，相比之下船帆+人力的组合更靠谱一些。
反思 看样子不是古人不够聪明，恰恰相反，是他们太聪明，蒸汽机并不是他们当时场景下的最佳的选择而没有被发明。
但是这么先进的东西，没有被发明确实一种遗憾，我们应该避免在当今年代遇到蒸汽机同样的问题。
庆幸我们这个时代有实验室、研究所这些机构，他们不用太关注经济利益，去研究科学。</description></item><item><title>IGC2022-05-16</title><link>https://blog.yearnfar.com/posts/igc2022-05-16/</link><pubDate>Mon, 16 May 2022 19:14:22 +0800</pubDate><guid>https://blog.yearnfar.com/posts/igc2022-05-16/</guid><description>最近连着下了几天雨，今天天气有转好的迹象，拍几张照片留作纪念。</description></item><item><title>su和su -和sudo区别</title><link>https://blog.yearnfar.com/posts/su%E5%92%8Csu-%E5%92%8Csudo%E5%8C%BA%E5%88%AB/</link><pubDate>Tue, 10 May 2022 19:24:06 +0800</pubDate><guid>https://blog.yearnfar.com/posts/su%E5%92%8Csu-%E5%92%8Csudo%E5%8C%BA%E5%88%AB/</guid><description>最近强迫症又犯了，把自己跑了4年的服务器重装了下系统。重装之后，开始认真的研究如何使用。
以前很少使用sudo这个命令，如果要root权限一般都是直接su 输入root密码。但是sudo明显要更加方便。于是就开启了sudo权限。
开启sudo visudo 在root下添加一行
## Allow root to run any commands anywhere root ALL=(ALL) ALL your_name ALL=(ALL) NOPASSWD: ALL su 与 su - 与 sudo su 不加任何参数，切换到root，不变环境变量(与切换前一致)。
su - ，切换到root，并且切换到root的环境变量。
sudo能使用root权限执行，但是需要注意使用时将PATH环境变量进行了重置，我们使用sudo visudo 在secure_path可以看到sudo所设置的PATH环境变量。
Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin:</description></item><item><title>Go1.18泛型实现并发安全的map</title><link>https://blog.yearnfar.com/posts/go1.18%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84map/</link><pubDate>Tue, 26 Apr 2022 00:03:52 +0800</pubDate><guid>https://blog.yearnfar.com/posts/go1.18%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84map/</guid><description>使用go泛型失效并发安全的map结构
package mut import ( &amp;#34;sync&amp;#34; ) type Map[K, V comparable] struct { mu sync.RWMutex values map[K]V } func (m *Map[K, V]) Put(key K, value V) { m.mu.Lock() m.values[key] = value m.mu.Unlock() } func (m *Map[K, V]) Get(key K) V { var v V m.mu.RLock() v = m.values[key] m.mu.RUnlock() return v } func NewMap[K, V comparable]() *Map[K, V] { m := &amp;amp;Map[K, V]{} m.values = make(map[K]V) return m }</description></item><item><title>数据库缓存一致性</title><link>https://blog.yearnfar.com/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</link><pubDate>Sat, 23 Apr 2022 21:24:40 +0800</pubDate><guid>https://blog.yearnfar.com/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</guid><description>在高并发场景下，保证数据库和缓存一致性
更新缓存有4中方案
先更新数据库，然后更新缓存 先更新缓存，然后更新数据库 先更新数据库，然后删除缓存 先删除缓存，然后更新数据库 下面我们分别分四种情况的高并发情况下，四种方案可能出现的问题：
先更新数据库，然后更新缓存 进程一、进程二都模拟了一个先更新数据库，后更新缓存的场景。
1、如果进程二更新缓存发生在进程一更新缓存之前（即t3变成了t3`），此时缓存值是v1，数据库值为v2，发生了数据库和缓存不一致的情况。
2、先更新数据库后更新缓存还存在如果该缓存使用率不高，浪费缓存空间的情况。
先更新缓存，然后更新数据库 进程一、进程二分别模拟了一个先更新缓存，后更新数据库的场景。
1、如果进程二更新数据库发生在进程一更新数据库之前（即t3变成了t3`），此时缓存值为v2，数据库值为v1，出现了缓存与数据库不一致的情况。
2、先更新缓存后更新数据库也存在也存在如果key对应缓存使用率不高，浪费缓存空间的情况。
先更新数据库，然后删除缓存 进程一、进程三模拟更新数据库并删除缓存。
进程二模拟首次生成缓存值。
从上面的图可以看出，如果t3-&amp;gt;t6时间段有更新数据库并删除缓存，则会出数据库中值为v2，但是缓存中值为v1的情况。这种概率几乎可以忽略不计，因为t3-&amp;gt; t6时间非常短，且更新数据库和删除缓存都必须都发生在这个时间才会导致上述情况。
但是，如果t1或者t5删除缓存失败，则会导致在缓存被删除或失效前读取到的都是旧值。所以这种方案需要确保删除缓存操作的可靠性很高。推荐的做法是，先删除一次，如果删除失败，再写入消息队列，使用消息队列的重试删除，直到删除成功为止。
先删除缓存，后更新数据库 进程一、进程三模拟删除缓存并更新数据库。
进程二模拟首次生成缓存值。
从上图可以看出，如果进程三在t5之前删除缓存，且在t5后更新数据库，则必然发生数据库中存的值与缓存中存的值不一致的情况。
进程一、进程三模拟删除缓存并更新数据库。
进程二模拟首次生成缓存值。
从上图可以看出，如果进程三在t4~t6之间还有写入数据库的操作，也必然发生数据库中存的值与缓存中存的值不一致的情况。</description></item><item><title>知识时光机</title><link>https://blog.yearnfar.com/posts/%E7%9F%A5%E8%AF%86%E6%97%B6%E5%85%89%E6%9C%BA/</link><pubDate>Tue, 05 Apr 2022 09:52:43 +0800</pubDate><guid>https://blog.yearnfar.com/posts/%E7%9F%A5%E8%AF%86%E6%97%B6%E5%85%89%E6%9C%BA/</guid><description>为什么要写博客 以前在开源中国上面写过一段时间的博客，偶尔也写一些原创性的，但是大多数还是已转载为主。可能是转载的转多了（可以转载为什么要原创），也可能是进步太慢（没有什么可以总结的），后来慢慢的也不写博客了。最近更加注重学习和总结，于是又重新拾起博客，让它记录我学习和成长的过程。
应该避免的问题 既然现在开始写博客，我想还是要先总结下以前放弃写博客的原因，以及怎么做才能不重蹈覆辙。
傻逼定律 写完一篇博客，过了一段时间回过头来看，发现分享的东西特别的初级或者分享的想法不够成熟。这个时候我往往会选择删掉它，或许这是打击我写博客的最大因素吧。人总是在成长，用以后的眼光看现在的东西是不对的，我应该以发现以前的自己是个“傻逼”而高兴，而不是去遮盖我以前是个“傻逼”的事实。
不转载 以前写博客总喜欢去转载别人的，或者大多数是别人的，自己只是在它的基础上重新组织下。转载就好像写代码的时候直接Copy别人的代码，对其中的很多东西了解的并不彻底。而且自己内心对转载的东西还是比较拒绝的，当发现自己的博客里面大部分都是转载的东西时，就觉得这已经不是自己的博客。慢慢也就没有了写作的兴趣，所以我觉得还是应该不转载其他人的文章。
心态问题 以前写一篇博客经常就1~2小时完成，超过了这个时间就觉得不值得，现在回想起来是自己心态也有问题。要真写好一篇博客，需要先选题、查找资料、有时候还要实践、最后才是总结。怎么也不像是1~2小时能完成的事情，如果要短时间内完成，往往也是粗制滥造。粗制滥造的多了，也会挫伤写作积极性。
写作方式 以前我一般是在第三方平台(如OSC)或者自己搭建的WordPress上对着编辑器写文章。心里总会有种压迫感，仿佛有人在等我提交。现在改用Hugo+Github Pages，就没有这种压迫感，不发布就不提交，文章保存在本地。而且要迁移也更加方便，我更喜欢这种写作方式。</description></item><item><title>Hello world</title><link>https://blog.yearnfar.com/posts/hello-world/</link><pubDate>Mon, 04 Apr 2022 21:35:16 +0800</pubDate><guid>https://blog.yearnfar.com/posts/hello-world/</guid><description>hello world!</description></item></channel></rss>