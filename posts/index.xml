<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 知识时光机</title><link>https://blog.yearnfar.com/posts/</link><description>Recent content in Posts on 知识时光机</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>yearnfar 2022</copyright><lastBuildDate>Fri, 03 Jun 2022 22:39:34 +0800</lastBuildDate><atom:link href="https://blog.yearnfar.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>中国移动宽带设置ipv6</title><link>https://blog.yearnfar.com/posts/%E4%B8%AD%E5%9B%BD%E7%A7%BB%E5%8A%A8%E5%AE%BD%E5%B8%A6%E8%AE%BE%E7%BD%AEipv6/</link><pubDate>Fri, 03 Jun 2022 22:39:34 +0800</pubDate><guid>https://blog.yearnfar.com/posts/%E4%B8%AD%E5%9B%BD%E7%A7%BB%E5%8A%A8%E5%AE%BD%E5%B8%A6%E8%AE%BE%E7%BD%AEipv6/</guid><description>由于国家大力推进IPv6，目前我们使用手机流量上网时都可以分配到IPv6地址。大家可以通过手机自带浏览器访问 https://test-ipv6.com/ 查看手机是否支持IPv6。
除了手机流量，我们还会使用WiFi上网，WiFi上网时，就未必是有IPv6地址了。目前主流的网络供应商应该也是支持IPv6的，问题大概率是出现在用户自己的路由是否支持IPv6和以及路由的设置上。
这以我的情况讲解下如何开启IPv6。
我使用的是中国移动宽带，接入户的是光纤。所以有一个光猫 + 自己购买的路由器。要支持IPv6需要满足3个条件：
移动入户的网络是否支持IPv6。 光猫支持IPv6。 自己购买的路由支持IPv6。 一般默认情况下，我们都是使用光猫拨号上网，路由自动获取IP地址的方式上网。这是联网的时候，运营商的小哥这么设定的。我建议改成光猫使用桥接模式，并通过路由拨号的方式上网。
光猫设置 光猫的后台地址一般是http://192.168.1.1
光猫的后面有一个账号useradmin和密码，但是这个账号权限太少，无法设置网络相关的东西，我们这里需要用到超级管理员，移动的超管账号是: CMCCAdmin 密码：aDm8H%MdA
登录之后，查看 网络 =&amp;gt;宽带设置=&amp;gt; 连接名称，连接名称一般有很多下拉选项。
其中有一项是PPPoe拨号的，选中该连接名称。
记录下宽带账号！密码如果没有修改过的话默认是手机号后六位，如果改过又不记得也可以去中国移动官网重置密码。
将模式改为Bridge、协议模式改为IPv4 &amp;amp; IPv6，并保存。其他的都可以不改（也不要去随便修改，我遇到过改了Vlan 设置导致拨号一直连不上网的情况，好在我在修改之前截图备份了，把参数改回去之后又正常了）。
保存之后，查看 状态 =&amp;gt; 网络侧信息，可以看到有一条类型是Bridge，协议是 IPv4 &amp;amp; IPv6，状态是 Connected 的记录。到这里，光猫部分的设置就已经完成了。
路由设置 进入到路由的后台，选择宽带账号上网，输入宽带账号，宽带密码，并联接，即可上网。
找到IPv6的设置菜单，打开IPv6，如果没有这个菜单，说明路由并不支持IPv6。
验证IPv6 方式一： 浏览器打开 http://test-ipv6.com/ 验证是否支持IPv6。
方式二 终端通过CURL获取当前电脑IPv6地址
➜ ~ curl https://myip6.ipip.net 当前 IP：2409:8a55:628:4250:4982:c8ad:****:**** 来自于：中国 广东 广州 移动</description></item><item><title>使用tinyproxy搭建代理服务器</title><link>https://blog.yearnfar.com/posts/%E4%BD%BF%E7%94%A8tinyproxy%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Sun, 29 May 2022 00:26:10 +0800</pubDate><guid>https://blog.yearnfar.com/posts/%E4%BD%BF%E7%94%A8tinyproxy%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>程序员都有遇到，需要在终端设置http_proxy的情况。这里介绍使用tinyproxy使得在终端科学上网。
源码编译安装Tinyproxy Tinyproxy项目地址
下载安装包到本地
[yearnfar@aws ~]$ wget https://github.com/tinyproxy/tinyproxy/releases/download/1.11.1/tinyproxy-1.11.1.tar.gz [yearnfar@aws ~]$ tar zxvf tinyproxy-1.11.1.tar.gz [yearnfar@aws ~]$ cd tinyproxy-1.11.1 [yearnfar@aws ~]$ ./configure --prefix=/usr/local/tinyproxy [yearnfar@aws ~]$ make # 如果提示性没有 gcc # [yearnfar@aws ~]$ make yum install gcc [yearnfar@aws ~]$ sudo make install [yearnfar@aws ~]$ cd /usr/local/tinyproxy [yearnfar@aws tinyproxy]$ ls bin etc share [yearnfar@aws tinyproxy]$ sudo cp -r etc/tinyproxy /etc/ # 将配置文件移动到/etc目录 修改配置文件
User nobody Group nobody # 为了避免被扫描到，最好修改一个端口 Port 8888 Timeout 600 DefaultErrorFile &amp;#34;/usr/local/tinyproxy/share/tinyproxy/default.</description></item><item><title>在Jetson Nano上跑yolov5</title><link>https://blog.yearnfar.com/posts/%E5%9C%A8jetson-nano%E4%B8%8A%E8%B7%91yolov5/</link><pubDate>Sun, 22 May 2022 18:16:32 +0800</pubDate><guid>https://blog.yearnfar.com/posts/%E5%9C%A8jetson-nano%E4%B8%8A%E8%B7%91yolov5/</guid><description>Jetson Naon搭建 参考官方文档：Jetson Nano 开发者套件入门
按照官方文档搭建好Jetson Nano环境后，可以看到/usr/local/cuda目录，将CUDA加入环境变量：
export CUDA_HOME=/usr/local/cuda export PATH=$CUDA_HOME/bin:$PATH export LD_LIBRARY_PATH=$CUDA_HOME/lib64:$LD_LIBRARY_PATH 查看CUDA信息
➜ ~ nvcc -V nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2021 NVIDIA Corporation Built on Sun_Feb_28_22:34:44_PST_2021 Cuda compilation tools, release 10.2, V10.2.300 Build cuda_10.2_r440.TC440_70.29663091_0 准备Python 以前一直使用Anaconda管理Python环境，但是在Jetson Nano安装Anaconda或Miniconda时都出现了&amp;quot;core dumped&amp;quot;，最后发现了miniforge 这个项目。
我这里安装的是4.12.0版本：Mambaforge-Linux-aarch64.sh
➜ ~ sudo ./Mambaforge-Linux-aarch64.sh 安装好Mamba后就是创建Python环境了。
因为PyTorch官方不提供ARM aarch64架构的CUDA版本，所以我下载Nvida官网编译好的二进制包。目前提供PyTorch1.0.0 ~ PyTorch1.12.0 总计13个版本可供选择。
PyTorch for Jetson
怎么选择PyTorch版本呢？我们可以看到不同的PyTorch版本对JetPack版本要求是不一样，先查看Jetson Nano的JetPack版本。
➜ ~ cat /etc/nv_tegra_release # R32 (release), REVISION: 7.2, GCID: 30192233, BOARD: t210ref, EABI: aarch64, DATE: Wed Apr 20 21:34:48 UTC 2022 可以看到默认安装的是JetPack R32，JetPack R32支持的PyTorch最高的版本是v1.</description></item><item><title>systemctl使用方式</title><link>https://blog.yearnfar.com/posts/systemctl%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</link><pubDate>Sun, 22 May 2022 17:53:42 +0800</pubDate><guid>https://blog.yearnfar.com/posts/systemctl%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</guid><description>以nginx为例，介绍如何使用systemctl 把程序做成服务。
配置 创建服务配置文件 nginx.service
[Unit] Description=The nginx HTTP and reverse proxy server After=network.target remote-fs.target nss-lookup.target [Service] Type=forking PIDFile=/run/nginx.pid # Nginx will fail to start if /run/nginx.pid already exists but has the wrong # SELinux context. This might happen when running `nginx -t` from the cmdline. # https://bugzilla.redhat.com/show_bug.cgi?id=1268621 ExecStartPre=/usr/bin/rm -f /run/nginx.pid ExecStartPre=/usr/sbin/nginx -t ExecStart=/usr/sbin/nginx ExecReload=/bin/kill -s HUP $MAINPID KillSignal=SIGQUIT TimeoutStopSec=5 KillMode=mixed PrivateTmp=true [Install] WantedBy=multi-user.target 将nginx.service 放到 /lib/systemd/system/ 目录，systemctl会在这个目录查找配置文件。
sudo mv nginx.</description></item><item><title>为什么中国古人不能发明蒸汽机</title><link>https://blog.yearnfar.com/posts/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%AD%E5%9B%BD%E5%8F%A4%E4%BA%BA%E4%B8%8D%E8%83%BD%E5%8F%91%E6%98%8E%E8%92%B8%E6%B1%BD%E6%9C%BA/</link><pubDate>Mon, 16 May 2022 21:38:00 +0800</pubDate><guid>https://blog.yearnfar.com/posts/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%AD%E5%9B%BD%E5%8F%A4%E4%BA%BA%E4%B8%8D%E8%83%BD%E5%8F%91%E6%98%8E%E8%92%B8%E6%B1%BD%E6%9C%BA/</guid><description>以现代视角来看，蒸汽机原理并不算复杂，为什么古人在几千年的历史中都没有发明蒸汽机？我从来没有怀疑过古人的聪明智慧，但是没有发明蒸汽机，我相信有其中的必然原因。于是我带着一台瓦特改良的蒸汽机开始了我的穿越之旅。
蒸汽机VS汉朝黄牛 首先我穿越来到了汉朝，虽然在汉朝人们已经开始使用煤炭，但是并没有大规模应用，我只能使用木材当做燃料。
我请了一个樵夫，帮我打柴，并把蒸汽机搬到了广场上，向人们展示我的蒸汽机。
“它能做什么”？有人问道。
“他能推动磨盘，所有需要人力的事他都能做！”
“哦，跟水车一样啊。我看你往里面加木柴，但是水车不需要木柴呢！”
“水车只能建在有水的地方，我这个可以建在所有有水的地方。” 我气愤的说道。
“没有水的地方可以使用牛啊”又有人说道。
我竟然无言以对，想想也是，牛只需要吃草，既然耕地，拉磨，也能拉车。
于是在汉朝黄牛VS 蒸汽机，蒸汽机败了。
蒸汽机VS大明船帆 在认真分析了汉朝的失败经验后，我决定穿越到明朝。原因有二：
明朝已经开始大规模使用煤炭了，燃料问题解决了。 明朝航海业发达，大船&amp;amp;蒸汽机是个不错的落地方案。 于是我直接穿越到了明朝，找到郑和，向他推销我的蒸汽机。
“大人，这个设备可以装到大船上，代替人力，只需要烧煤炭就可以了。”我说道
“这个东西这么大，船甲板能承受得了这个重量吗？”郑和问道。
“甲板上都用铁板就可以了”。我自信满满的说道
“装满煤炭能去下西洋吗？到了没有煤的地方怎么办呢？”。郑和问道
“我&amp;hellip;&amp;quot;
到了明朝，我的蒸汽机竟然面临了和新能源一样的困境，里程焦虑。并不是每个地方都可以买到煤，相比之下船帆+人力的组合更靠谱一些。
反思 看样子不是古人不够聪明，恰恰相反，是他们太聪明，蒸汽机并不是他们当时场景下的最佳的选择而没有被发明。
但是这么先进的东西，没有被发明确实一种遗憾，我们应该避免在当今年代遇到蒸汽机同样的问题。庆幸的是我们这个时代有实验室、研究所这些机构，他们不用太关注经济利益，去研究科学。</description></item><item><title>IGC2022-05-16</title><link>https://blog.yearnfar.com/posts/igc2022-05-16/</link><pubDate>Mon, 16 May 2022 19:14:22 +0800</pubDate><guid>https://blog.yearnfar.com/posts/igc2022-05-16/</guid><description>最近连着下了几天雨，今天天气有转好的迹象，拍几张照片留作纪念。</description></item><item><title>su和su -和sudo区别</title><link>https://blog.yearnfar.com/posts/su%E5%92%8Csu-%E5%92%8Csudo%E5%8C%BA%E5%88%AB/</link><pubDate>Tue, 10 May 2022 19:24:06 +0800</pubDate><guid>https://blog.yearnfar.com/posts/su%E5%92%8Csu-%E5%92%8Csudo%E5%8C%BA%E5%88%AB/</guid><description>最近强迫症又犯了，把自己跑了4年的服务器重装了下系统。重装之后，开始认真的研究如何使用。
以前很少使用sudo这个命令，如果要root权限一般都是直接su 输入root密码。但是sudo明显要更加方便。于是就开启了sudo权限。
开启sudo visudo 在root下添加一行
## Allow root to run any commands anywhere root ALL=(ALL) ALL your_name ALL=(ALL) NOPASSWD: ALL su 与 su - 与 sudo su 不加任何参数，切换到root，不变环境变量(与切换前一致)。
su - ，切换到root，并且切换到root的环境变量。
sudo能使用root权限执行，但是需要注意使用时将PATH环境变量进行了重置，我们使用sudo visudo 在secure_path可以看到sudo所设置的PATH环境变量。
Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin:</description></item><item><title>Go1.18泛型实现并发安全的map</title><link>https://blog.yearnfar.com/posts/go1.18%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84map/</link><pubDate>Tue, 26 Apr 2022 00:03:52 +0800</pubDate><guid>https://blog.yearnfar.com/posts/go1.18%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84map/</guid><description>使用go泛型失效并发安全的map结构
package mut import ( &amp;#34;sync&amp;#34; ) type Map[K, V comparable] struct { mu sync.RWMutex values map[K]V } func (m *Map[K, V]) Put(key K, value V) { m.mu.Lock() m.values[key] = value m.mu.Unlock() } func (m *Map[K, V]) Get(key K) V { var v V m.mu.RLock() v = m.values[key] m.mu.RUnlock() return v } func NewMap[K, V comparable]() *Map[K, V] { m := &amp;amp;Map[K, V]{} m.values = make(map[K]V) return m }</description></item><item><title>数据库缓存一致性</title><link>https://blog.yearnfar.com/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</link><pubDate>Sat, 23 Apr 2022 21:24:40 +0800</pubDate><guid>https://blog.yearnfar.com/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</guid><description>在高并发场景下，保证数据库和缓存一致性
更新缓存有4中方案
先更新数据库，然后更新缓存 先更新缓存，然后更新数据库 先更新数据库，然后删除缓存 先删除缓存，然后更新数据库 下面我们分别分四种情况的高并发情况下，四种方案可能出现的问题：
先更新数据库，然后更新缓存 进程一、进程二都模拟了一个先更新数据库，后更新缓存的场景。
1、如果进程二更新缓存发生在进程一更新缓存之前（即t3变成了t3`），此时缓存值是v1，数据库值为v2，发生了数据库和缓存不一致的情况。
2、先更新数据库后更新缓存还存在如果该缓存使用率不高，浪费缓存空间的情况。
先更新缓存，然后更新数据库 进程一、进程二分别模拟了一个先更新缓存，后更新数据库的场景。
1、如果进程二更新数据库发生在进程一更新数据库之前（即t3变成了t3`），此时缓存值为v2，数据库值为v1，出现了缓存与数据库不一致的情况。
2、先更新缓存后更新数据库也存在也存在如果key对应缓存使用率不高，浪费缓存空间的情况。
先更新数据库，然后删除缓存 进程一、进程三模拟更新数据库并删除缓存。
进程二模拟首次生成缓存值。
从上面的图可以看出，如果t3-&amp;gt;t6时间段有更新数据库并删除缓存，则会出数据库中值为v2，但是缓存中值为v1的情况。这种概率几乎可以忽略不计，因为t3-&amp;gt; t6时间非常短，且更新数据库和删除缓存都必须都发生在这个时间才会导致上述情况。
但是，如果t1或者t5删除缓存失败，则会导致在缓存被删除或失效前读取到的都是旧值。所以这种方案需要确保删除缓存操作的可靠性很高。推荐的做法是，先删除一次，如果删除失败，再写入消息队列，使用消息队列的重试删除，直到删除成功为止。
先删除缓存，后更新数据库 进程一、进程三模拟删除缓存并更新数据库。
进程二模拟首次生成缓存值。
从上图可以看出，如果进程三在t5之前删除缓存，且在t5后更新数据库，则必然发生数据库中存的值与缓存中存的值不一致的情况。
进程一、进程三模拟删除缓存并更新数据库。
进程二模拟首次生成缓存值。
从上图可以看出，如果进程三在t4~t6之间还有写入数据库的操作，也必然发生数据库中存的值与缓存中存的值不一致的情况。</description></item><item><title>知识时光机</title><link>https://blog.yearnfar.com/posts/%E7%9F%A5%E8%AF%86%E6%97%B6%E5%85%89%E6%9C%BA/</link><pubDate>Tue, 05 Apr 2022 09:52:43 +0800</pubDate><guid>https://blog.yearnfar.com/posts/%E7%9F%A5%E8%AF%86%E6%97%B6%E5%85%89%E6%9C%BA/</guid><description>为什么要写博客 以前在开源中国上面写过一段时间的博客，偶尔也写一些原创性的，但是大多数还是已转载为主。可能是转载的转多了（可以转载为什么要原创），也可能是进步太慢（没有什么可以总结的），后来慢慢的也不写博客了。最近更加注重学习和总结，于是又重新拾起博客，让它记录我学习和成长的过程。
应该避免的问题 既然现在开始写博客，我想还是要先总结下以前放弃写博客的原因，以及怎么做才能不重蹈覆辙。
傻逼定律 写完一篇博客，过了一段时间回过头来看，发现分享的东西特别的初级或者分享的想法不够成熟。这个时候我往往会选择删掉它，或许这是打击我写博客的最大因素吧。人总是在成长，用以后的眼光看现在的东西是不对的，我应该以发现以前的自己是个“傻逼”而高兴，而不是去遮盖我以前是个“傻逼”的事实。
不转载 以前写博客总喜欢去转载别人的，或者大多数是别人的，自己只是在它的基础上重新组织下。转载就好像写代码的时候直接Copy别人的代码，对其中的很多东西了解的并不彻底。而且自己内心对转载的东西还是比较拒绝的，当发现自己的博客里面大部分都是转载的东西时，就觉得这已经不是自己的博客。慢慢也就没有了写作的兴趣，所以我觉得还是应该不转载其他人的文章。
心态问题 以前写一篇博客经常就1~2小时完成，超过了这个时间就觉得不值得，现在回想起来是自己心态也有问题。要真写好一篇博客，需要先选题、查找资料、有时候还要实践、最后才是总结。怎么也不像是1~2小时能完成的事情，如果要短时间内完成，往往也是粗制滥造。粗制滥造的多了，也会挫伤写作积极性。
写作方式 以前我一般是在第三方平台(如OSC)或者自己搭建的WordPress上对着编辑器写文章。心里总会有种压迫感，仿佛有人在等我提交。现在改用Hugo+Github Pages，就没有这种压迫感，不发布就不提交，文章保存在本地。而且要迁移也更加方便，我更喜欢这种写作方式。</description></item><item><title>Hello World</title><link>https://blog.yearnfar.com/posts/hello-world/</link><pubDate>Mon, 04 Apr 2022 21:35:16 +0800</pubDate><guid>https://blog.yearnfar.com/posts/hello-world/</guid><description>hello world!</description></item></channel></rss>