---
title: "数据库缓存一致性"
date: 2022-04-23T21:24:40+08:00
description: ""
tags: []
featured_image: ""
# images is optional, but needed for showing Twitter Card
images: []
categories:
comment: true
draft: true
---

在高并发场景下，保证数据库和缓存一致性

更新缓存有4中方案

- 先更新数据库，然后更新缓存
- 先更新缓存，然后更新数据库
- 先更新数据库，然后删除缓存
- 先删除缓存，然后更新数据库

下面我们分别分四种情况的高并发情况下，四种方案可能出现的问题：

### 先更新数据库，然后更新缓存

![](/images/先更新数据库后更新缓存.drawio.png)

进程一、进程二都模拟了一个先更新数据库，后更新缓存的场景。

1、如果进程更新缓存发生时间在进程一更新缓存之前，即t3变成了t3`，这时存储的缓存值是v1。发生了数据库和缓存不一致的情况。

2、如果更新后的这个key对应的缓存使用率不高，则会导致缓存空间的浪费。

### 先更新缓存，然后更新数据库

先更新缓存后更新数据库，会遇到的问题似乎更多：

1、更新缓存成功后，更新数据库失败的情况，





### 先更新数据库，然后删除缓存

![](/images/先更新数据库后删除缓存.drawio.png)

进程一、进程三模拟更新数据库并删除缓存。

进程二、进程四模拟读取缓存值，区别在于进程二是读取缓存不存在，从数据库中取值并写入数据库。

从上面的图可以看出，如果t5->t7时间段其他进程读取缓存值，则读取到的值是v1，而此时数据库中的值是v2。出现了不一致。考虑到，t7 - t5 是一个比较短的时间，出现异常的概率是比较小的。

但是，如果t1或者t7删除缓存失败，则会导致缓存被删除或失效前，读取到的都是旧值。所以这种方案需要确保删除缓存可靠性很高。推荐的做法是，先删除一次，如果删除是失败，再写入消息队列，使用消息队列的重试功能区删除，直到删除成功为止。







