<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>泛型 on 知识时光机</title><link>https://blog.yearnfar.com/tags/%E6%B3%9B%E5%9E%8B/</link><description>Recent content in 泛型 on 知识时光机</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>yearnfar 2022</copyright><lastBuildDate>Tue, 26 Apr 2022 00:03:52 +0800</lastBuildDate><atom:link href="https://blog.yearnfar.com/tags/%E6%B3%9B%E5%9E%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Go1.18泛型实现并发安全的map</title><link>https://blog.yearnfar.com/posts/go1.18%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84map/</link><pubDate>Tue, 26 Apr 2022 00:03:52 +0800</pubDate><guid>https://blog.yearnfar.com/posts/go1.18%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84map/</guid><description>使用go泛型失效并发安全的map结构
package mut import ( &amp;#34;sync&amp;#34; ) type Map[K, V comparable] struct { mu sync.RWMutex values map[K]V } func (m *Map[K, V]) Put(key K, value V) { m.mu.Lock() m.values[key] = value m.mu.Unlock() } func (m *Map[K, V]) Get(key K) V { var v V m.mu.RLock() v = m.values[key] m.mu.RUnlock() return v } func NewMap[K, V comparable]() *Map[K, V] { m := &amp;amp;Map[K, V]{} m.values = make(map[K]V) return m }</description></item></channel></rss>